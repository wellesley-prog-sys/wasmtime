#472	cls_8
expansion {
	term = lower
	rules = [
		cls_8
		output_reg
		sub_imm
		a64_cls
		../../../codegen/src/isa/aarch64/inst.isle line 3305
		extend
		bit_rr
		alu_rr_imm12_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [65], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: ALUOp	make_variant(ALUOp::Sub, [])
		27: BitOp	make_variant(BitOp::Cls, [])
		30: Type	extractor(value_type, 8)
		31: Option(Type)	extractor(fits_in_32, 30)
		32: Reg	constructor(put_in_reg, [8], 1)
		33: bool	const_prim(true)
		34: Type	match_some(31)
		35: u8	constructor(ty_bits, [34], 0)
		36: u8	const_int(32, u8)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 32, 33, 35, 36])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [10], 2)
		53: MInst	make_variant(MInst::BitRR, [27, 52, 51, 46])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [10], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [23, 62, 61, 55, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		31:	some
	]
	parameters = [
		0
	]
	result = 16
	feasible = true
}
