#915	rotl_32_base_case
	rotl(bv 8, bv 8) -> bv 8
		type solution status = inapplicable
	rotl(bv 16, bv 16) -> bv 16
		type solution status = inapplicable
	rotl(bv 32, bv 32) -> bv 32
		type solution status = solved
		applicability = applicable
		verification = failure
model:
has_type(32, #x00000000) -> #x00000000
rotl(#x00000000, #x80000000) -> #x00000000
put_in_regs(#x80000000) -> {lo: #x0000000080000000, hi: #x0000000000000000}
value_regs_get({lo: #x0000000080000000, hi: #x0000000000000000}, 0) -> #x0000000080000000
zero_reg() -> #x0000000000000000
put_in_reg(#x00000000) -> #x0000000000000000
temp_writable_reg(64) -> #xffffffffffffffff
writable_reg_to_reg(#xffffffffffffffff) -> #xffffffffffffffff
value_reg(#xffffffffffffffff) -> {lo: #xffffffffffffffff, hi: #xffffffffffffffff}
output({lo: #xffffffffffffffff, hi: #xffffffffffffffff}) -> #xffffffff
ALUOp.RotR() -> RotR {}
ALUOp.Sub() -> Sub {}
temp_writable_reg(64) -> #x0000000080000000
operand_size(32) -> Size32 {}
MInst.AluRRR(Sub {}, Size32 {}, #x0000000080000000, #x0000000000000000, #x0000000080000000) -> {flags_in: {N: #b0, Z: #b0, C: #b0, V: #b0}, flags_out: {N: #b0, Z: #b0, C: #b0, V: #b0}}
emit({flags_in: {N: #b0, Z: #b0, C: #b0, V: #b0}, flags_out: {N: #b0, Z: #b0, C: #b0, V: #b0}}) -> #b1
writable_reg_to_reg(#x0000000080000000) -> #x0000000080000000
operand_size(32) -> Size32 {}
MInst.AluRRR(RotR {}, Size32 {}, #xffffffffffffffff, #x0000000000000000, #x0000000080000000) -> {flags_in: {N: #b0, Z: #b0, C: #b0, V: #b0}, flags_out: {N: #b0, Z: #b0, C: #b0, V: #b0}}
emit({flags_in: {N: #b0, Z: #b0, C: #b0, V: #b0}, flags_out: {N: #b0, Z: #b0, C: #b0, V: #b0}}) -> #b1
lower(#x00000000) -> #xffffffff
