use std::collections::HashMap;
use std::io;
use std::io::Write;
use std::path::{Path, PathBuf};

use anyhow::{bail, Result};
use clap::Parser as ClapParser;
use cranelift_codegen::{
    ir::MemFlags,
    isa::aarch64::inst::{
        writable_xreg, xreg, ALUOp, ALUOp3, AMode, BitOp, ExtendOp, Imm12, Inst, OperandSize,
        ShiftOp, ShiftOpAndAmt, ShiftOpShiftImm,
    },
    Reg, Writable,
};
use cranelift_isle::{
    ast::{Def, SpecOp},
    printer,
};
use cranelift_isle_veri_aslp::client::Client;
use cranelift_isle_veri_isaspec::{
    aarch64::{self, pstate_field},
    bits::{Bits, Segment},
    builder::{
        Arm, Builder, Case, Cases, InstConfig, Mapping, MappingBuilder, Mappings, Match, Opcodes,
        SpecConfig,
    },
    constraints::Target,
    memory::ReadEffect,
    spec::{
        spec_binary, spec_const_bit_vector, spec_const_int, spec_discriminator, spec_eq,
        spec_eq_bool, spec_extract, spec_field, spec_var,
    },
};
use itertools::Itertools;

#[derive(ClapParser)]
#[command(version, about)]
struct Args {
    /// Server URL
    #[arg(long = "server", required = true)]
    server: String,

    // Output directory.
    #[arg(long, required = true)]
    output: PathBuf,

    // Maximum line width.
    #[arg(long, default_value = "120")]
    width: usize,

    /// Print debugging output (repeat for more detail)
    #[arg(short = 'd', long = "debug", action = clap::ArgAction::Count)]
    debug_level: u8,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Setup tracing output.
    tracing_subscriber::fmt()
        .with_writer(io::stderr)
        .with_timer(tracing_subscriber::fmt::time::uptime())
        .with_level(true)
        .with_target(false)
        .with_max_level(match args.debug_level {
            0 => tracing::Level::WARN,
            1 => tracing::Level::INFO,
            2 => tracing::Level::DEBUG,
            _ => tracing::Level::TRACE,
        })
        .init();

    // ASLp client.
    let http_client = reqwest::blocking::Client::new();
    let client = Client::new(&http_client, args.server)?;

    // Conversion.
    let file_configs = define()?;
    for file_config in file_configs {
        // Generate specs.
        let mut defs = Vec::new();
        for spec_config in file_config.specs {
            let builder = Builder::new(spec_config, &client);
            let def = builder.build()?;
            defs.push(def);
        }

        // Output.
        let path = args.output.join(file_config.name);
        write_spec(&path, &defs, args.width)?;
    }

    Ok(())
}

fn write_spec(path: &Path, defs: &Vec<Def>, width: usize) -> Result<()> {
    let mut output = std::fs::File::create(path)?;

    // Code generation warning.
    writeln!(output, ";; GENERATED BY `isaspec`. DO NOT EDIT!!!")?;
    writeln!(output)?;

    // Format with ISLE printer.
    printer::print(defs, width, &mut output)?;

    Ok(())
}

/// Configuration for an ISLE specification file to generate.
struct FileConfig {
    name: PathBuf,
    specs: Vec<SpecConfig>,
}

/// Define specifications to generate.
fn define() -> Result<Vec<FileConfig>> {
    Ok(vec![
        FileConfig {
            name: "alu_rrr.isle".into(),
            specs: vec![define_alu_rrr()],
        },
        FileConfig {
            name: "alu_rrrr.isle".into(),
            specs: vec![define_alu_rrrr()],
        },
        FileConfig {
            name: "alu_rr_imm12.isle".into(),
            specs: vec![define_alu_rr_imm12()?],
        },
        FileConfig {
            name: "alu_rrr_shift.isle".into(),
            specs: vec![define_alu_rrr_shift()?],
        },
        FileConfig {
            name: "alu_rrr_extend.isle".into(),
            specs: vec![define_alu_rrr_extend()],
        },
        FileConfig {
            name: "bit_rr.isle".into(),
            specs: vec![define_bit_rr()],
        },
        FileConfig {
            name: "loads.isle".into(),
            specs: define_loads(),
        },
        FileConfig {
            name: "extend.isle".into(),
            specs: vec![define_extend()],
        },
    ])
}

// MInst.AluRRR specification configuration.
fn define_alu_rrr() -> SpecConfig {
    let alu_ops = [
        ALUOp::Add,
        ALUOp::Sub,
        ALUOp::Orr,
        ALUOp::OrrNot,
        ALUOp::And,
        ALUOp::AndNot,
        ALUOp::Eor,
        ALUOp::EorNot,
        ALUOp::AddS,
        ALUOp::SubS,
        ALUOp::SMulH,
        ALUOp::UMulH,
        ALUOp::SDiv,
        ALUOp::UDiv,
        ALUOp::Adc,
        // --------------
        // Shift variable is 6-bits:
        // ALUOp::Lsr,
        // ALUOp::Asr,
        // ALUOp::Lsl,
        // ALUOp::RotR,
        //
        // Flag ops not required yet:
        // ALUOp::Sbc,
        // ALUOp::AdcS,
        // ALUOp::SbcS,
    ];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    // AluRRR
    let mut mappings = flags_mappings();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    SpecConfig {
        // Spec signature.
        term: "MInst.AluRRR".to_string(),
        args: ["alu_op", "size", "rd", "rn", "rm"]
            .map(String::from)
            .to_vec(),

        cases: Cases::Match(Match {
            on: spec_var("size".to_string()),
            arms: sizes
                .iter()
                .rev()
                .map(|size| Arm {
                    variant: format!("{size:?}"),
                    args: Vec::new(),
                    body: Cases::Match(Match {
                        on: spec_var("alu_op".to_string()),
                        arms: alu_ops
                            .iter()
                            .filter(|alu_op| is_alu_op_size_supported(**alu_op, *size))
                            .map(|alu_op| Arm {
                                variant: format!("{alu_op:?}"),
                                args: Vec::new(),
                                body: Cases::Instruction(InstConfig {
                                    opcodes: Opcodes::Instruction(Inst::AluRRR {
                                        alu_op: *alu_op,
                                        size: *size,
                                        rd: writable_xreg(4),
                                        rn: xreg(5),
                                        rm: xreg(6),
                                    }),
                                    scope: aarch64::state(),
                                    mappings: mappings.clone(),
                                }),
                            })
                            .collect(),
                    }),
                })
                .collect(),
        }),
    }
}

fn is_alu_op_size_supported(alu_op: ALUOp, size: OperandSize) -> bool {
    match alu_op {
        ALUOp::SMulH | ALUOp::UMulH | ALUOp::SDiv | ALUOp::UDiv => size == OperandSize::Size64,
        _ => true,
    }
}

// MInst.AluRRRR specification configuration.
fn define_alu_rrrr() -> SpecConfig {
    // ALUOp3
    let alu3_ops = [ALUOp3::MAdd, ALUOp3::MSub, ALUOp3::UMAddL, ALUOp3::SMAddL];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    let mut mappings = Mappings::default();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(7),
        Mapping::require(spec_var("ra".to_string())),
    );

    SpecConfig {
        // Spec signature.
        term: "MInst.AluRRRR".to_string(),
        args: ["alu_op", "size", "rd", "rn", "rm", "ra"]
            .map(String::from)
            .to_vec(),

        cases: Cases::Match(Match {
            on: spec_var("size".to_string()),
            arms: sizes
                .iter()
                .rev()
                .map(|size| Arm {
                    variant: format!("{size:?}"),
                    args: Vec::new(),
                    body: Cases::Match(Match {
                        on: spec_var("alu_op".to_string()),
                        arms: alu3_ops
                            .iter()
                            .filter(|alu3_op| is_alu3_op_size_supported(**alu3_op, *size))
                            .map(|alu_op| Arm {
                                variant: format!("{alu_op:?}"),
                                args: Vec::new(),
                                body: Cases::Instruction(InstConfig {
                                    opcodes: Opcodes::Instruction(Inst::AluRRRR {
                                        alu_op: *alu_op,
                                        size: *size,
                                        rd: writable_xreg(4),
                                        rn: xreg(5),
                                        rm: xreg(6),
                                        ra: xreg(7),
                                    }),
                                    scope: aarch64::state(),
                                    mappings: mappings.clone(),
                                }),
                            })
                            .collect(),
                    }),
                })
                .collect(),
        }),
    }
}

fn is_alu3_op_size_supported(alu3_op: ALUOp3, size: OperandSize) -> bool {
    match alu3_op {
        ALUOp3::UMAddL | ALUOp3::SMAddL => size == OperandSize::Size32,
        _ => true,
    }
}

// MInst.AluRRImm12 specification configuration.
fn define_alu_rr_imm12() -> Result<SpecConfig> {
    // ALUOps supported by AluRRImm12.
    let alu_ops = [
        ALUOp::Add,
        ALUOp::Sub,
        // ALUOp::AddS,
        // ALUOp::SubS,
    ];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    // Imm12.shift12
    let shift12s = [false, true];

    // Execution scope: define opcode template fields.
    let mut scope = aarch64::state();
    let imm12_bits = Target::Var("bits".to_string());
    scope.global(imm12_bits.clone());

    // Mappings
    let mut mappings = flags_mappings();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    mappings.reads.insert(
        imm12_bits.clone(),
        MappingBuilder::var("imm12").field("bits").build(),
    );

    Ok(SpecConfig {
        term: "MInst.AluRRImm12".to_string(),
        args: ["alu_op", "size", "rd", "rn", "imm12"]
            .map(String::from)
            .to_vec(),
        cases: Cases::Match(Match {
            on: spec_var("size".to_string()),
            arms: sizes
                .iter()
                .rev()
                .map(|size| {
                    Ok(Arm {
                        variant: format!("{size:?}"),
                        args: Vec::new(),
                        body: Cases::Match(Match {
                            on: spec_var("alu_op".to_string()),
                            arms: alu_ops
                                .iter()
                                .map(|alu_op| {
                                    Ok(Arm {
                                        variant: format!("{alu_op:?}"),
                                        args: Vec::new(),
                                        body: Cases::Cases(
                                            shift12s
                                                .iter()
                                                .map(|shift12| {
                                                    let template = alu_rr_imm12_template(
                                                        *alu_op,
                                                        *size,
                                                        writable_xreg(4),
                                                        xreg(5),
                                                        *shift12,
                                                    )?;
                                                    Ok(Case {
                                                        conds: vec![spec_eq_bool(
                                                            spec_field(
                                                                "shift12".to_string(),
                                                                spec_var("imm12".to_string()),
                                                            ),
                                                            *shift12,
                                                        )],
                                                        cases: Cases::Instruction(InstConfig {
                                                            opcodes: Opcodes::Template(template),
                                                            scope: scope.clone(),
                                                            mappings: mappings.clone(),
                                                        }),
                                                    })
                                                })
                                                .collect::<Result<_>>()?,
                                        ),
                                    })
                                })
                                .collect::<Result<_>>()?,
                        }),
                    })
                })
                .collect::<Result<_>>()?,
        }),
    })
}

fn alu_rr_imm12_template(
    alu_op: ALUOp,
    size: OperandSize,
    rd: Writable<Reg>,
    rn: Reg,
    shift12: bool,
) -> Result<Bits> {
    // Assemble a base instruction with a placeholder for the imm12 field.
    let placeholder = Imm12 { bits: 0, shift12 };
    let base = Inst::AluRRImm12 {
        alu_op,
        size,
        rd,
        rn,
        imm12: placeholder,
    };
    let opcode = aarch64::opcode(&base);
    let bits = Bits::from_u32(opcode);

    // Splice in symbolic immediate fields.
    let imm = Bits {
        segments: vec![Segment::Symbolic("bits".to_string(), 12)],
    };
    let template = Bits::splice(&bits, &imm, 10)?;

    // Verify template against the assembler.
    verify_opcode_template(&template, |assignment: &HashMap<String, u32>| {
        let bits = assignment.get("bits").unwrap();
        let imm12 = Imm12 {
            bits: (*bits).try_into().unwrap(),
            shift12,
        };
        Ok(Inst::AluRRImm12 {
            alu_op,
            size,
            rd,
            rn,
            imm12,
        })
    })?;

    Ok(template)
}

// MInst.AluRRRShift specification configuration.
fn define_alu_rrr_shift() -> Result<SpecConfig> {
    // ALUOps supported by AluRRImm12.
    let alu_ops = [
        ALUOp::Add,
        ALUOp::Sub,
        ALUOp::Orr,
        ALUOp::And,
        ALUOp::Eor,
        ALUOp::OrrNot,
        ALUOp::EorNot,
        ALUOp::AndNot,
        // Flags:
        // ALUOp::AddS,
        // ALUOp::SubS,
        // ALUOp::AndS,
    ];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    // ShiftOp
    let shiftops = [
        ShiftOp::LSL,
        ShiftOp::LSR,
        ShiftOp::ASR,
        // ShiftOp::ROR is defined variant but actually not a valid opcode
    ];

    Ok(SpecConfig {
        term: "MInst.AluRRRShift".to_string(),
        args: ["alu_op", "size", "rd", "rn", "rm", "shiftop"]
            .map(String::from)
            .to_vec(),
        cases: Cases::Match(Match {
            on: spec_var("alu_op".to_string()),
            arms: alu_ops
                .iter()
                .map(|alu_op| {
                    Ok(Arm {
                        variant: format!("{alu_op:?}"),
                        args: Vec::new(),

                        // Shift operation cases.
                        //
                        // Note that the `ShiftOpAndAmt` model actually uses
                        // `ALUOp` to represent the shift operation.  ISLE does
                        // not actually materialize the ShiftOp type itself, and
                        // without support for ghost types, we cannot represent
                        // it.  Therefore, co-opting ALUOp for the purpose is
                        // the best we can do.
                        body: Cases::Match(Match {
                            on: spec_field("op".to_string(), spec_var("shiftop".to_string())),
                            arms: shiftops
                                .iter()
                                .map(|shiftop| {
                                    // Map shift operation to the correspondong ALUOp.
                                    let alu_shift_op = alu_op_from_shiftop(*shiftop);
                                    Ok(Arm {
                                        variant: format!("{alu_shift_op:?}"),
                                        args: Vec::new(),
                                        body: Cases::Cases(
                                            sizes
                                                .iter()
                                                .rev()
                                                .map(|size| {
                                                    alu_rrr_shift_size_case(
                                                        *alu_op, *size, *shiftop,
                                                    )
                                                })
                                                .collect::<Result<_>>()?,
                                        ),
                                    })
                                })
                                .collect::<Result<_>>()?,
                        }),
                    })
                })
                .collect::<Result<_>>()?,
        }),
    })
}

fn alu_rrr_shift_size_case(alu_op: ALUOp, size: OperandSize, op: ShiftOp) -> Result<Case> {
    // Shift amount field depends on operand size.
    let amt_width = match size {
        OperandSize::Size32 => 5,
        OperandSize::Size64 => 6,
    };
    let amt_var = format!("amt{}", amt_width);

    // Setup scope with shift amount variable.
    let amt_target = Target::Var(amt_var.clone());
    let mut scope = aarch64::state();
    scope.global(amt_target.clone());

    // Expressions for the shift amount.
    //
    // The model of the shift amount is an 8 bit value, but the instruction
    // representations only allow 5 or 6 bits (depending on operand size).  We
    // extract the shift bits from the operand, and require that the higher bits
    // are zero.
    static FULL_AMT_WIDTH: usize = 8;
    let full_amt_expr = spec_field("amt".to_string(), spec_var("shiftop".to_string()));
    let amt_expr = spec_extract(amt_width - 1, 0, full_amt_expr.clone());
    let amt_overflow_expr = spec_extract(FULL_AMT_WIDTH - 1, amt_width, full_amt_expr.clone());
    let amt_overflow_width = FULL_AMT_WIDTH - amt_width;
    let no_amt_overflow = spec_eq(
        amt_overflow_expr,
        spec_const_bit_vector(0, amt_overflow_width),
    );

    // Mappings
    let mut mappings = flags_mappings();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );
    mappings
        .reads
        .insert(amt_target.clone(), Mapping::require(amt_expr.clone()));

    // Opcode template
    //
    // Assemble a base instruction with a placeholder for the shift amount.
    let placeholder = ShiftOpShiftImm::maybe_from_shift(0).unwrap();
    let rd = writable_xreg(4);
    let rn = xreg(5);
    let rm = xreg(6);
    let shiftop = ShiftOpAndAmt::new(op, placeholder);
    let base = Inst::AluRRRShift {
        alu_op,
        size,
        rd,
        rn,
        rm,
        shiftop,
    };
    let opcode = aarch64::opcode(&base);
    let bits = Bits::from_u32(opcode);

    // Splice in symbolic shift amount.
    //
    // The shift amount is 6 bits in the 64-bit case, and 5 bits in the 32-bit
    // case.  Note that in the 32-bit case, the instruction is explicitly
    // undefined when bit 5 is 1. Therefore, we must ensure that the symbolic
    // field variable is only 5 bits.
    let amt = Bits {
        segments: vec![Segment::Symbolic(amt_var.to_string(), amt_width)],
    };
    let template = Bits::splice(&bits, &amt, 10)?;

    // Verify template against the assembler.
    verify_opcode_template(&template, |assignment: &HashMap<String, u32>| {
        let amt = assignment.get(&amt_var).unwrap();
        let shift = ShiftOpShiftImm::maybe_from_shift((*amt).into()).unwrap();
        let shiftop = ShiftOpAndAmt::new(op, shift);
        Ok(Inst::AluRRRShift {
            alu_op,
            size,
            rd,
            rn,
            rm,
            shiftop,
        })
    })?;

    Ok(Case {
        conds: vec![
            spec_discriminator(format!("{size:?}"), spec_var("size".to_string())),
            no_amt_overflow,
        ],
        cases: Cases::Instruction(InstConfig {
            opcodes: Opcodes::Template(template),
            scope: scope.clone(),
            mappings: mappings.clone(),
        }),
    })
}

fn alu_op_from_shiftop(op: ShiftOp) -> ALUOp {
    match op {
        ShiftOp::LSL => ALUOp::Lsl,
        ShiftOp::LSR => ALUOp::Lsr,
        ShiftOp::ASR => ALUOp::Asr,
        ShiftOp::ROR => ALUOp::RotR,
    }
}

// MInst.AluRRRExtend specification configuration.
fn define_alu_rrr_extend() -> SpecConfig {
    // ALUOps supported by AluRRRExtend.
    let alu_ops = [ALUOp::Add, ALUOp::Sub, ALUOp::AddS, ALUOp::SubS];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    // ExtendOp
    let extendops = [
        ExtendOp::UXTB,
        ExtendOp::UXTH,
        ExtendOp::UXTW,
        ExtendOp::UXTX,
        ExtendOp::SXTB,
        ExtendOp::SXTH,
        ExtendOp::SXTW,
        ExtendOp::SXTX,
    ];

    // AluRRR
    let mut mappings = flags_mappings();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    SpecConfig {
        term: "MInst.AluRRRExtend".to_string(),
        args: ["alu_op", "size", "rd", "rn", "rm", "extendop"]
            .map(String::from)
            .to_vec(),

        cases: Cases::Match(Match {
            on: spec_var("size".to_string()),
            arms: sizes
                .iter()
                .rev()
                .map(|size| Arm {
                    variant: format!("{size:?}"),
                    args: Vec::new(),
                    body: Cases::Match(Match {
                        on: spec_var("alu_op".to_string()),
                        arms: alu_ops
                            .iter()
                            .map(|alu_op| Arm {
                                variant: format!("{alu_op:?}"),
                                args: Vec::new(),
                                body: Cases::Match(Match {
                                    on: spec_var("extendop".to_string()),
                                    arms: extendops
                                        .into_iter()
                                        .map(|extendop| Arm {
                                            variant: format!("{extendop:?}"),
                                            args: Vec::new(),
                                            body: Cases::Instruction(InstConfig {
                                                opcodes: Opcodes::Instruction(Inst::AluRRRExtend {
                                                    alu_op: *alu_op,
                                                    size: *size,
                                                    rd: writable_xreg(4),
                                                    rn: xreg(5),
                                                    rm: xreg(6),
                                                    extendop,
                                                }),
                                                scope: aarch64::state(),
                                                mappings: mappings.clone(),
                                            }),
                                        })
                                        .collect(),
                                }),
                            })
                            .collect(),
                    }),
                })
                .collect(),
        }),
    }
}

// MInst.BitRR specification configuration.
fn define_bit_rr() -> SpecConfig {
    // BitRR
    let bit_ops = [
        BitOp::Cls,
        // --------------
        // BitOp::RBit,
        // BitOp::Clz,
        // BitOp::Rev16,
        // BitOp::Rev32,
        // BitOp::Rev64,
    ];

    // OperandSize
    let sizes = [OperandSize::Size32, OperandSize::Size64];

    let mut mappings = Mappings::default();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );

    SpecConfig {
        // Spec signature.
        term: "MInst.BitRR".to_string(),
        args: ["op", "size", "rd", "rn"].map(String::from).to_vec(),

        cases: Cases::Match(Match {
            on: spec_var("size".to_string()),
            arms: sizes
                .iter()
                .rev()
                .map(|size| Arm {
                    variant: format!("{size:?}"),
                    args: Vec::new(),
                    body: Cases::Match(Match {
                        on: spec_var("op".to_string()),
                        arms: bit_ops
                            .iter()
                            .map(|op| Arm {
                                variant: format!("{op:?}"),
                                args: Vec::new(),
                                body: Cases::Instruction(InstConfig {
                                    opcodes: Opcodes::Instruction(Inst::BitRR {
                                        op: *op,
                                        size: *size,
                                        rd: writable_xreg(4),
                                        rn: xreg(5),
                                    }),
                                    scope: aarch64::state(),
                                    mappings: mappings.clone(),
                                }),
                            })
                            .collect(),
                    }),
                })
                .collect(),
        }),
    }
}

fn define_extend() -> SpecConfig {
    // Extend
    let signed = [false, true];
    let bits = [8u8, 16u8, 32u8, 64u8];

    let mut mappings = Mappings::default();
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );
    mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );

    SpecConfig {
        // Spec signature.
        term: "MInst.Extend".to_string(),
        args: ["rd", "rn", "signed", "from_bits", "to_bits"]
            .map(String::from)
            .to_vec(),
        cases: Cases::Cases(
            bits.iter()
                .cartesian_product(&bits)
                .filter(|(from_bits, to_bits)| from_bits < to_bits)
                .cartesian_product(&signed)
                .map(|((from_bits, to_bits), signed)| Case {
                    conds: vec![
                        spec_eq_bool(spec_var("signed".to_string()), *signed),
                        spec_eq(
                            spec_var("from_bits".to_string()),
                            spec_const_int((*from_bits).into()),
                        ),
                        spec_eq(
                            spec_var("to_bits".to_string()),
                            spec_const_int((*to_bits).into()),
                        ),
                    ],
                    cases: Cases::Instruction(InstConfig {
                        // Instruction to generate specification from.
                        opcodes: Opcodes::Instruction(Inst::Extend {
                            rd: writable_xreg(4),
                            rn: xreg(5),
                            signed: *signed,
                            from_bits: *from_bits,
                            to_bits: *to_bits,
                        }),
                        scope: aarch64::state(),
                        mappings: mappings.clone(),
                    }),
                })
                .collect(),
        ),
    }
}

fn define_loads() -> Vec<SpecConfig> {
    // ULoad8
    let uload8 = define_load("MInst.ULoad8", 8, |rd, mem, flags| Inst::ULoad8 {
        rd,
        mem,
        flags,
    });

    // SLoad8
    let sload8 = define_load("MInst.SLoad8", 8, |rd, mem, flags| Inst::SLoad8 {
        rd,
        mem,
        flags,
    });

    // ULoad16
    let uload16 = define_load("MInst.ULoad16", 16, |rd, mem, flags| Inst::ULoad16 {
        rd,
        mem,
        flags,
    });

    // SLoad16
    let sload16 = define_load("MInst.SLoad16", 16, |rd, mem, flags| Inst::SLoad16 {
        rd,
        mem,
        flags,
    });

    // ULoad32
    let uload32 = define_load("MInst.ULoad32", 32, |rd, mem, flags| Inst::ULoad32 {
        rd,
        mem,
        flags,
    });

    // SLoad32
    let sload32 = define_load("MInst.SLoad32", 32, |rd, mem, flags| Inst::SLoad32 {
        rd,
        mem,
        flags,
    });

    // ULoad64
    let uload64 = define_load("MInst.ULoad64", 64, |rd, mem, flags| Inst::ULoad64 {
        rd,
        mem,
        flags,
    });

    vec![uload8, sload8, uload16, sload16, uload32, sload32, uload64]
}

fn define_load<F>(term: &str, size_bits: usize, inst: F) -> SpecConfig
where
    F: Fn(Writable<Reg>, AMode, MemFlags) -> Inst,
{
    // Mappings.
    let mut mappings = Mappings::default();

    // Destination register.
    mappings.writes.insert(
        aarch64::gpreg(4),
        Mapping::require(spec_var("rd".to_string())),
    );

    // ISA load state mapped to read effect.
    let read_effect = ReadEffect::new();
    static ISA_LOAD: &str = "isa_load";
    static LOADED_VALUE: &str = "loaded_value";
    mappings.writes.insert(
        read_effect.active,
        MappingBuilder::state(ISA_LOAD).field("active").build(),
    );
    mappings.writes.insert(
        read_effect.addr,
        MappingBuilder::state(ISA_LOAD).field("addr").build(),
    );
    mappings.writes.insert(
        read_effect.size_bits,
        MappingBuilder::state(ISA_LOAD).field("size_bits").build(),
    );
    mappings.reads.insert(
        read_effect.value,
        Mapping::require(spec_binary(
            SpecOp::ConvTo,
            spec_const_int(size_bits.try_into().unwrap()),
            spec_var(LOADED_VALUE.to_string()),
        )),
    );

    // RegReg
    let mut reg_reg_mappings = mappings.clone();
    reg_reg_mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    reg_reg_mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    let reg_reg = Arm {
        variant: "RegReg".to_string(),
        args: ["rn", "rm"].map(String::from).to_vec(),
        body: Cases::Instruction(InstConfig {
            opcodes: Opcodes::Instruction(inst(
                writable_xreg(4),
                AMode::RegReg {
                    rn: xreg(5),
                    rm: xreg(6),
                },
                MemFlags::new(),
            )),
            scope: aarch64::state(),
            mappings: reg_reg_mappings,
        }),
    };

    // RegScaled
    let mut reg_scaled_mappings = mappings.clone();
    reg_scaled_mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    reg_scaled_mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    let reg_scaled = Arm {
        variant: "RegScaled".to_string(),
        args: ["rn", "rm"].map(String::from).to_vec(),
        body: Cases::Instruction(InstConfig {
            opcodes: Opcodes::Instruction(inst(
                writable_xreg(4),
                AMode::RegScaled {
                    rn: xreg(5),
                    rm: xreg(6),
                },
                MemFlags::new(),
            )),
            scope: aarch64::state(),
            mappings: reg_scaled_mappings,
        }),
    };

    // RegScaledExtended
    let extendops = [
        // Not supported by assembler: UXTB, UXTH, UXTX, SXTB, SXTH
        ExtendOp::UXTW,
        ExtendOp::SXTW,
        ExtendOp::SXTX,
    ];
    let mut reg_scaled_extended_mappings = mappings.clone();
    reg_scaled_extended_mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    reg_scaled_extended_mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    let reg_scaled_extended = Arm {
        variant: "RegScaledExtended".to_string(),
        args: ["rn", "rm", "extendop"].map(String::from).to_vec(),
        body: Cases::Match(Match {
            on: spec_var("extendop".to_string()),
            arms: extendops
                .into_iter()
                .map(|extendop| Arm {
                    variant: format!("{extendop:?}"),
                    args: Vec::new(),
                    body: Cases::Instruction(InstConfig {
                        opcodes: Opcodes::Instruction(inst(
                            writable_xreg(4),
                            AMode::RegScaledExtended {
                                rn: xreg(5),
                                rm: xreg(6),
                                extendop,
                            },
                            MemFlags::new(),
                        )),
                        scope: aarch64::state(),
                        mappings: reg_scaled_extended_mappings.clone(),
                    }),
                })
                .collect(),
        }),
    };

    // RegExtended
    let mut reg_extended_mappings = mappings.clone();
    reg_extended_mappings.reads.insert(
        aarch64::gpreg(5),
        Mapping::require(spec_var("rn".to_string())),
    );
    reg_extended_mappings.reads.insert(
        aarch64::gpreg(6),
        Mapping::require(spec_var("rm".to_string())),
    );

    let reg_extended = Arm {
        variant: "RegExtended".to_string(),
        args: ["rn", "rm", "extendop"].map(String::from).to_vec(),
        body: Cases::Match(Match {
            on: spec_var("extendop".to_string()),
            arms: extendops
                .into_iter()
                .map(|extendop| Arm {
                    variant: format!("{extendop:?}"),
                    args: Vec::new(),
                    body: Cases::Instruction(InstConfig {
                        opcodes: Opcodes::Instruction(inst(
                            writable_xreg(4),
                            AMode::RegExtended {
                                rn: xreg(5),
                                rm: xreg(6),
                                extendop,
                            },
                            MemFlags::new(),
                        )),
                        scope: aarch64::state(),
                        mappings: reg_extended_mappings.clone(),
                    }),
                })
                .collect(),
        }),
    };

    SpecConfig {
        term: term.to_string(),
        args: ["rd", "mem", "flags"].map(String::from).to_vec(),
        cases: Cases::Match(Match {
            on: spec_var("mem".to_string()),
            arms: vec![reg_reg, reg_scaled, reg_scaled_extended, reg_extended],
        }),
    }
}

fn flags_mappings() -> Mappings {
    // Instruction model is the MInst value itself, which is considered the result of the variant term.
    let inst = MappingBuilder::var("result").allow();

    // Input and output flags of the instruction are fields of the MInst model.
    let flags_in = inst.clone().field("flags_in");
    let flags_out = inst.clone().field("flags_out");

    // Construct read and write mappings for each NZCV field.
    let mut mappings = Mappings::default();
    for field in &["N", "Z", "C", "V"] {
        // Read
        mappings
            .reads
            .insert(pstate_field(field), flags_in.clone().field(field).build());

        // Write
        mappings
            .writes
            .insert(pstate_field(field), flags_out.clone().field(field).build());
    }

    mappings
}

// Compare an opcode template against the instruction we expect it to represent.
fn verify_opcode_template<F>(template: &Bits, expect: F) -> Result<()>
where
    F: Fn(&HashMap<String, u32>) -> Result<Inst>,
{
    // Iterate over all template values.
    for concrete in template.into_iter() {
        let inst = expect(&concrete.assignment)?;
        let opcode = aarch64::opcode(&inst);
        let got = concrete.eval()?;
        if got != opcode {
            bail!("template mismatch");
        }
    }
    Ok(())
}
