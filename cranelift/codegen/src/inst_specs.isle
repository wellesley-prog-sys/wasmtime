(model Imm64 (type (bv 64)))

; REVIEW(mbm): do we need to model MemFlags?
(model MemFlags (type
    (struct
        (aligned Bool)
        (trapcode (bv 4))
    )
))

(model Offset32 (type (bv 32)))

(spec (iadd x y)
    (provide (= result (bvadd x y))))
(instantiate iadd
    ((args (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
    ((args (bv 128) (bv 128)) (ret (bv 128)))
)

(spec (isub x y)
    (provide (= result (bvsub x y))))
(instantiate isub
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(spec (imul x y)
    (provide (= result (bvmul x y))))
(instantiate imul
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(spec (iconst arg)
    (provide (= arg (zero_ext 64 result))))
(instantiate iconst
    ((args (bv 64)) (ret (bv 64)))
)

(spec (ishl x y)
    (provide
        (= result
            (bvshl
                x
                (bvand y (conv_to (widthof y) (bvsub (int2bv 64 (widthof y)) #x0000000000000001)))
            )
        )
    )
)
(instantiate ishl
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(spec (band x y)
    (provide (= result (bvand x y))))
(instantiate band
    ((args (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(spec (bor x y)
    (provide (= result (bvor x y))))
(instantiate bor
    ((args (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(spec (bnot x)
    (provide (= result (bvnot x))))
(instantiate bnot
    ((args (bv 8)) (ret (bv 8)))
    ((args (bv 16)) (ret (bv 16)))
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)

(model IntCC
      (enum (bv 4)
            (Equal #x0)
            (NotEqual #x1)
            (SignedGreaterThan #x2)
            (SignedGreaterThanOrEqual #x3)
            (SignedLessThan #x4)
            (SignedLessThanOrEqual #x5)
            (UnsignedGreaterThan #x6)
            (UnsignedGreaterThanOrEqual #x7)
            (UnsignedLessThan #x8)
            (UnsignedLessThanOrEqual #x9)   
      )
)

(spec (icmp c x y)
    (provide
        (= result
            (switch c
                ((IntCC.Equal) (if (= x y) #x01 #x00))
                ((IntCC.NotEqual) (if (not (= x y)) #x01 #x00))
                ((IntCC.SignedGreaterThan) (if (bvsgt x y) #x01 #x00))
                ((IntCC.SignedGreaterThanOrEqual) (if (bvsge x y) #x01 #x00))
                ((IntCC.SignedLessThan) (if (bvslt x y) #x01 #x00))
                ((IntCC.SignedLessThanOrEqual) (if (bvsle x y) #x01 #x00))
                ((IntCC.UnsignedGreaterThan) (if (bvugt x y) #x01 #x00))
                ((IntCC.UnsignedGreaterThanOrEqual) (if (bvuge x y) #x01 #x00))
                ((IntCC.UnsignedLessThan) (if (bvult x y) #x01 #x00))
                ((IntCC.UnsignedLessThanOrEqual) (if (bvule x y) #x01 #x00)))))
(require
        ;; AVH TODO: if we understand enums semantically, we can generate this
        (or
            (= c (IntCC.Equal))
            (= c (IntCC.NotEqual))
            (= c (IntCC.UnsignedGreaterThanOrEqual))
            (= c (IntCC.UnsignedGreaterThan))
            (= c (IntCC.UnsignedLessThanOrEqual))
            (= c (IntCC.UnsignedLessThan))
            (= c (IntCC.SignedGreaterThanOrEqual))
            (= c (IntCC.SignedGreaterThan))
            (= c (IntCC.SignedLessThanOrEqual))
            (= c (IntCC.SignedLessThan)))))

;; (instantiate iadd
;;     ((args (bv 8) (bv 8)) (ret (bv 8)))

(instantiate icmp
    ((args (bv 8) (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 8) (bv 16) (bv 16)) (ret (bv 8)))
    ((args (bv 8) (bv 32) (bv 32)) (ret (bv 8)))
    ((args (bv 8) (bv 64) (bv 64)) (ret (bv 8)))
)