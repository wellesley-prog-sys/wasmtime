;;;; Verification Type Models ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(model Imm64 (type (bv 64)))

; REVIEW(mbm): do we need to model MemFlags?
(model MemFlags (type
    (struct
        (aligned Bool)
        (trapcode (bv 4))
    )
))

(model Offset32 (type (bv 32)))

;;;; State Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Value loaded from memory.
;
; We deliberately do not attempt to model the entire state of memory. Modeling a
; loaded value this way allows us to express the fact that loaded values on CLIF
; and ISA side will be equivalent (combined with an assertion on address
; equality).
(state loaded_value
    (type (bv 64))
    (default true)
)

; Parameters of a CLIF load operation.
(state clif_load
    (type
        (struct
            (active Bool)
            (size_bits Int)
            (addr (bv 64))
        )
    )
    (default
        (not (:active clif_load))
    )
)

;;;; Common Term Forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(form
    bv_unary_8_to_64
    ((args (bv  8)) (ret (bv  8)))
    ((args (bv 16)) (ret (bv 16)))
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)

(form
    bv_binary_8_to_64
    ((args (bv  8) (bv  8)) (ret (bv  8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
)

(form
    bv_ternary_8_to_64
    ((args (bv  8) (bv  8) (bv  8)) (ret (bv  8)))
    ((args (bv 16) (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64) (bv 64)) (ret (bv 64)))
)

;;;; CLIF Instruction Specifications ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(spec (iadd x y)
    (provide (= result (bvadd x y))))
(instantiate iadd
    ((args (bv 8) (bv 8)) (ret (bv 8)))
    ((args (bv 16) (bv 16)) (ret (bv 16)))
    ((args (bv 32) (bv 32)) (ret (bv 32)))
    ((args (bv 64) (bv 64)) (ret (bv 64)))
    ((args (bv 128) (bv 128)) (ret (bv 128)))
)

(spec (isub x y)
    (provide (= result (bvsub x y))))
(instantiate isub bv_binary_8_to_64)

(spec (ineg x)
    (provide (= result (bvneg x))))
(instantiate ineg bv_unary_8_to_64)

(spec (imul x y)
    (provide (= result (bvmul x y))))
(instantiate imul bv_binary_8_to_64)

(spec (iconst arg)
    (provide (= arg (zero_ext 64 result))))
(instantiate iconst
    ((args (bv 64)) (ret (bv 64)))
)

(spec (ishl x y)
    (provide
        (= result
            (bvshl
                x
                (bvand y (conv_to (widthof y) (bvsub (int2bv 64 (widthof y)) #x0000000000000001)))
            )
        )
    )
)
(instantiate ishl bv_binary_8_to_64)

(spec (band x y)
    (provide (= result (bvand x y))))
(instantiate band bv_binary_8_to_64)

(spec (bor x y)
    (provide (= result (bvor x y))))
(instantiate bor bv_binary_8_to_64)

(spec (bnot x)
    (provide (= result (bvnot x))))
(instantiate bnot bv_unary_8_to_64)

(spec (bitselect c x y)
    (provide (= result (bvor (bvand c x) (bvand (bvnot c) y)))))
(instantiate bitselect bv_ternary_8_to_64)

(spec (cls x) (provide (= result (cls x))))
(instantiate cls
    ((args (bv 8)) (ret (bv 8)))
    ((args (bv 16)) (ret (bv 16)))
    ((args (bv 32)) (ret (bv 32)))
    ((args (bv 64)) (ret (bv 64)))
)

(spec (load flags p offset)
    (modifies clif_load loaded_value)
    (provide
        ; Activate the CLIF load effect
        (:active clif_load)

        ; TODO(mbm): load flags

        ; Load size is the width of the loaded value.
        (= (:size_bits clif_load) (widthof result))

        ; Address calculation.
        (= (:addr clif_load) (bvadd p (sign_ext 64 offset)))

        ; Result of the load is represented by low bits of the loaded value state register.
        (= result (conv_to (widthof result) loaded_value))
    )
)
(instantiate load
    ((args (named MemFlags) (named Value) (named Offset32)) (ret (bv 64)))
)

(attr uextend (tag TODO))
(attr sextend (tag TODO))
